\section{Tor}
The Internet was designed as a public network and everything we do on the web is tracked and logged in general. Nevertheless today we have a lot of tools that we use everyday and that scale perfectly to guarantee the security of our interactions with a service (e.g. encryption). However, these tools doesn't do anything for guaranteeing our anonymity. If we setup a HTTPS channel, and someone places itself in the middle trying to check the content of the channel, he will not be able to look at the content, but he will perfectly aware of the fact that we are trying to communicate with a specific website at a specific point in time. He will able also to track statistical information such as how many times we connect to such website, average session duration, etc. For anonymity we means that whatever we do on the web, we should not be identifiable as the source or the destination of that activity. It stems from two different aspects : 
\begin{itemize}
\item \textbf{Unlinkability} of actions and identity : if someone observes what we are doing, he is not be able to understand what we are doing.
\item \textbf{Unobservability} : even if an adversary is observing what we are doing, he has no way to understand which system or protocol we are using.
\end{itemize}
The attacker to break unlinkability requirement can possibly perform passive or active traffic analysis. The first one means trying to look at packet flow on a network link, and try to infer who is talking whom. Active traffic analysis where the attacker is able to actively inject data in the system and may use the effect of these network data to try to identify someone or some service. We also assume that, the attacker in order to perform its analysis is able to compromise some network nodes such as routers, firewalls, etc. The idea is that we can't trust the underlying network on top of which the Internet is based for anonymity. Actually we need to build something on top of the network that allows us to overcome all the threats paused by the previous threat model and still guarantee unlinkability between users while they communicate. There are several proposals dedicated for implementing anonymous services for end users, \textbf{The Onion Router (Tor)} is by far the most successful among all these projects. TOR is a service that we run on our device and other software can use to route traffic in anonymous way towards the desired destination. In general, TOR is distributed anonymous overlay network that allows participants to exchange information in a completely anonymous fashion. An interesting point is that, thanks to its architecture, TOR allows its users also to access open standard web services. In this way the client is completely anonymized wrt the server. TOR offers another kind of functionality that goes under the name of \textbf{hidden services} that also implement the other side of anonymity. It allows users to access in an anonymous fashion services that are by themselves anonymous. In this case both the client and server identity are not revealed to the other endpoint of the channel.
\subsection{Architecture}
In Tor we have the following actors :
\begin{itemize}
\item \textbf{Client} : the user of the Tor network
\item \textbf{Server} : the target TCP application such as web servers
\item \textbf{Tor router} : the special proxy relays the application data
\item \textbf{Directory server} : they are servers holding Tor router information.
\end{itemize}
How Tor works ? Assume that Alice is trying to contact Bob to obtain a service from him. To do that, the first thing that Alice needs to do is to create a protected, encrypted and anonymous link to Bob using the Tor network. In particular, she contact Dave, which represent one of the Tor directory server, to obtain a link to a certain number of Tor relays. A Tor relay is a Tor service running on the pc of someone on the web. At this point Alice will receive the identity of $3$ relays (we assumed assumed such number for simplicity) and use them to create an encrypted link, where each of them represent an intermediate hop before contacting Bob. In other words, Alice is creating a virtual circuit within the Tor network, that will make her exchange data with Bob, but indirectly. Alice will be anonymous wrt Bob, because her packets will be indirectly received by Bob through the last Tor relay in the virtual circuit setup by Alice. So why the directory server provides Alice the identity of $3$ Tor relays ? Because virtual circuits in Tor are made up of three relay nodes. The first node is called \textbf{guard relay}, a middle relay and an exit relay. The guard relay is the first Tor relay that is contacted directly by Alice to send data towards Bob. The exit relay is the last relay node in the virtual circuit, that has the role to interact directly with Bob. The middle relay is in charge to decouple the interactions between the guard relay and exit relay. Even within the Tor relay network, connections in a virtual circuit are performed through intermediate nodes. This approach is completely different from the standard approach used by VPNs. Suppose Alice connect to the VPN using some protocol such as IPSec, and this means that we are setting up a virtual channel that is encrypted between us and the VPN server that is provided by our VPN provider. Next, the VPN server will immediately contact Bob (there will be a single indirection node between the two endpoints). This is a problem for the anonymity endpoint, because while Bob still sees packets coming from a VPN server and not directly from Alice, the VPN server itself has full visibility of what happens between Alice and Bob. Thus the unlinkability property that is needed for anonymity is not satisfied by VPN services. The usage of three intermediate relays in the construction of the Tor virtual private channel, is exactly what is needed by Tor to guarantee unlinkability. Notice that, a virtual circuit typically tend to last the whole session of an interaction between Alice and Bob. Thus, the traffic between Alice and Jane, will pass over a completely different and uncorrelated channel wrt the channel between Alice and Bob. This is needed to avoid the Tor network itself to be able to snoop upon Alice interactions with external services. The magic of unlinkability is provided within a virtual channel by a routing approach called \textbf{Onion Routing}. The basic concept is that Alice will send data to its endpoint using the virtual channel, but will encrypt data whose destination is Bob using a specific encryption approach called \textbf{Onion-like encryption}. In particular, to send data Alice encrypts data applying several layers of encryption that are setup such that each layer can be removed by a single onion relay. The data will first be encrypted using a symmetric key shared between Alice and the exit relay of the virtual circuit. Next, the data is encrypted again with a symmetric key shared between Alice and the middle relay of the circuit. Then, the data is encrypted again using a symmetric key shared between Alice and the guard relay. 

\paragraph{Tor circuit setup} First of all the client establish a symmetric key with the guard relay and to start the creation of a virtual circuit. In doing so the client exposes its identity to the guard relay. Thus the guard relay will act as an intermediate actor between the client and the middle relay in the virtual circuit. In particular, the client receives from the directory server together with the identity of the relays some information, like their IP address, but also their public key. At this point the client uses this public key to encrypt a session key that is sent through the guard relay towards the middle relay. The middle relay receives a request to setup the virtual circuit and the guard relay will include in such request also a virtual circuit identifier. Now, the middle relay will setup the data structures associated to this new virtual circuit and will decrypt the received session key, and will use it to create a symmetric key that will be used to exchange data with the client. The symmetric key is encrypted with the session key sent by the client, and it will send back to the client passing through the guard relay. In this way, the client and the middle relay can setup their shared key in such a way that the identity of the client is never disclosed to the middle relay. The same approach is used to setup the symmetric key with the exit relay, but the requests will be related by the guard and middle relay towards the exit relay. At the end of this protocol, all three relays will share a symmetric key with the client that is know only  by the client and the specific relay node. Once the virtual circuit is created, then it can be used to contact other external services using the symmetric keys for encryption. In order to deanonymize the connection made by a user towards a specific endpoint, an attacker should control all the three relays in the virtual circuit.\\\\The design of Tor is made up of several components that collaborate to implement the functionalities that we have seen so far. At the first level we have the overlay network which is constituted by virtual routers that works at user level, and that interconnect and communicate with other routers such to realize a network on top of another network. It's important to known that onion routers are implemented through software that normal people execute on their own computers or servers and it's made up to work with standard user privileges. Then we have the onion proxy, which is the software needed to be installed by users in order to connect to the Tor overlay network and make use of its functionalities. Tor for implementing at network level the way routers and proxy exchange information is by using TCP with TLS in order to avoid Tor traffic to be easily filtered on firewalls (in this way Tor hides that we are using it). Another characteristics of the network data flow generated by Tor is that all data sent by Tor is sent in fixed size cells in order to reducing the amount of information that can be get by looking at the size of the packets. However, the packet frequency is not always the same, since the exit relay of the virtual circuit adds some noise to the frequency of packets that are sent toward the endpoint. Other functionalities that are enforced by Tor design are the following : all packets are checked for integrity, there is a mechanism called \textbf{link throttling} to avoid congestion on links (especially for links that interconnects onion routers). There is also a form of traffic throttling that is applied at the level of virtual circuit; if in the virtual circuit there are too much requests going in one direction without enough answers coming back from the endpoint of the connection, further requests will be throttled waiting for the response to come back. However, the problem of having a public list of onion routers is that they can be all filtered out, avoiding the creation of a virtual circuit at all. To overcome this limitation the Tor project also keeps a sort of secret list of alternative onion routers that are called \textbf{onion bridges}. The directory servers doesn't known the onion bridges, since they are not part of the public list of onion routers. If we live in place where we cannot connect to Tor, because the connection to standard onion routers is filtered, we may ask the Tor project to provide us with a link with the identity of an onion bridge. The bridge acts as an intermediate point between the proxy and the guard router in the virtual circuit. The bridge will create virtual circuits on behalf of the proxy that is behind a firewall.

\subsection{Hidden services}
Hidden services are Internet services that are accessible only through Tor overlay network, they are not visible or usable through the standard Internet. The idea of making a service available through Tor is that the owner and administrators of those services have their identity anonymized. Anyone can connect to this website without knowing who is running that website. The original idea behind hidden services was to create something that was resistant to censorship. Setting up a hidden service is similar to setting up a virtual circuit for a client that wants to exchange data with an external service. In this case, it makes sense that both client and the service has their own virtual circuit, because in this case we want to ensure the anonymity for both of them. Now, we need to understand how Tor make sure that these virtual circuits have a point in common, that is an onion router where the two circuits collapse on the same point. 

\paragraph{Hidden service setup} Suppose that Bob wants to expose a hidden service. The first step to provide such service is that the proxy on Bob side selects a certain number (typically $3$) of onion routers chosen at random. These onion routers are called \textbf{introduction points}. These introduction points are contacted by Bob by setting up three independent virtual circuits. Each introduction point doesn't know the identity of Bob. Then Bob locally creates a sort of service identity token that contains several information such service name, unique identifier of the service, list of introductions points and the service public key. Notice that the identity of a hidden service typically in Tor takes this form \textit{service\_name.onion}. This token is then published by Bob in a public database. This database is a single place where users can possibly query for information about available hidden services. If Alice wants to access the hidden service, she queries the database for the information token about the service. Then she selects at random an onion router that will be called the \textbf{rendezvous point} for the connection between Alice and Bob. Now the problem is that, Alice needs a way to say to Bob in an anonymous manner, let's talk using that onion router. For this reason, Alice creates a connection request token, that is made up by setting up a piece of information that contains a cookie (a random number generated by Alice) and the identity of the rendezvous point selected by her. All these information are encrypted using the hidden service public key, which was contained in the information obtained by querying the database. Alice takes this encrypted request and creates a virtual circuit toward one of the three introduction points previously chosen by Bob (list of introduction points obtained again from the database). Next, she send to the chosen introduction point this request token, asking to it to route the request toward the hidden service. Once Bob obtains the request from Alice, he will decrypt the request using its private key. First of all he checks the identity of the rendezvous point. If for some reason Bob decide that some rendezvous points are not eligible for setting up connections, he will simply drop the request. Alice takes a TTL on the request, if it's not satisfied within a certain amount of time by Bob, she will try to make a new request selecting a new rendezvous point. If the rendezvous point chosen by Alice is ok for Bob, then Bob will create a virtual circuit towards the rendezvous point providing as information the cookie. At the same time also Alice creates a virtual circuit towards the rendezvous point, and place on it a connection token that contains the same cookie. This is the way the rendezvous point will be able to match two different virtual channels one coming from Alice, the other one coming from the hidden service, that both contains the same cookie. Once the rendezvous point sees the same cookie coming from the two virtual channels, it will connect them and act as a router between them. This means that all data that needs to go from Alice to the hidden service will pass through the rendezvous point. In particular, starting from Alice the data will reach the rendezvous point, and then proceed on the virtual circuit between this latter and the hidden service. By using two independent virtual circuits, we guarantee that the rendezvous point will not know anything about the identity of both Alice and Bob (the hidden service itself). At the same time we guarantee that Bob will not know nothing the identity of Alice and Alice will not know anything about the identity of Bob.\\\\Since the database represent a single point of failure, it's implemented in Tor by the whole community of onion routers through what is called \textbf{distributed hash table}. It works exactly as a hash table, the only difference is that it's implemented through different machines, where each of them stores a subset of all the possible keys. Then it's implemented through a distributed protocol that enables us to access every key-value pair that is stored, by simply querying one node that makes up this distributed hash table, and the internal protocol will make sure that, by forwarding our request through several nodes, we will able to reach the node that actually keeps in memory that key-value pair that we are looking for. Furthermore, this kind of data structure implemented mechanisms that allow to replicate data such that if a node that stores a portion of data of the table fails, the data will be replicated on a different node. They also allow for a dynamic implementation of the hash table. Nodes that implement the distributed hash table can enter or leave the overlay network, and data will not be lost. When a node enters the overlay network a portion of existing data will be moved on this node. When a node leave the network the data that it handles will be moved to another node.